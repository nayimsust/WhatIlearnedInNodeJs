/*
Copyright (c) AppDynamics, Inc., and its affiliates
2015
All Rights Reserved
*/
'use strict';


function PgProbe(agent) {
  this.agent = agent;

  this.packages = ['pg'];
}
exports.PgProbe = PgProbe;



PgProbe.prototype.attach = function(obj) {
  var self = this;

  if(obj.__appdynamicsProbeAttached__) return;
  obj.__appdynamicsProbeAttached__ = true;

  var proxy = self.agent.proxy;
  var profiler = self.agent.profiler;

  function probe(obj) {
    if(obj.__appdynamicsProbeAttached__) return;
    obj.__appdynamicsProbeAttached__ = true;

    proxy.after(obj, 'connect', function(obj, args, ret) {
      var props;
      var supportedProperties = {
        'HOST': obj.host,
        'PORT': obj.port,
        'DATABASE': obj.database,
        'VERSION': undefined,
        'VENDOR': 'POSTGRESQL'
      };

      obj.connection.on('parameterStatus', function(msg) {
        if (msg.parameterName !== 'server_version') {
          return;
        }
        supportedProperties.VERSION = msg.parameterValue;
      });

      // Callback API
      proxy.around(obj, 'query', function(obj, args, locals) {
        if (!props) {
          props = populateProperties(self.agent, supportedProperties);
          if (!props) {
            return;
          }
        }

        locals.time = profiler.time();
        locals.exitCall = createExitCall(self.agent, obj, locals.time, args, props);

        var hasCallback = proxy.callback(args, -1, function(obj, args) {
          if (locals.exitCall) {
            if(!locals.time.done()) return;
            var error = proxy.getErrorObject(args);
            profiler.addExitCall(locals.time, locals.exitCall, error);
          }
        });

        if(locals.exitCall && !hasCallback) {
          if(locals.time.done()) {
            profiler.addExitCall(locals.time, locals.exitCall);
          }
        }
      }, function(obj, args, ret, locals) { // Evented API
        if (!props) {
          props = populateProperties(self.agent, supportedProperties);
          if (!props) {
            return;
          }
        }

        // If has a callback, ignore
        if (args.length > 0 && typeof args[args.length - 1] === 'function') {
          return;
        }

        proxy.before(ret, 'on', function(obj, args) {
          var event = args[0];

          if(event !== 'end' && event !== 'error') return;

          var error;
          proxy.callback(args, -1, function(obj, args) {
            if(event === 'error') {
              error = proxy.getErrorObject(args);
              return;
            }

            if(locals.exitCall) {
              if(!locals.time.done()) return;
              profiler.addExitCall(locals.time, locals.exitCall, error);
            }
          });
        });
      });
    });
  }

  // Native, reinitialize probe
  proxy.getter(obj, 'native', function(obj, ret) {
    proxy.after(ret, 'Client', function(obj, args, ret) {
      probe(ret.__proto__);
    });
  });

  probe(obj.Client.prototype);
};

function populateProperties(agent, supportedProperties) {
  var backendConfig = agent.backendConfig.getDbConfig(supportedProperties);
  // if there's no backend config (OOTB or custom), then ignore this exit call
  if (!backendConfig) {
    return undefined;
  }

  var properties = agent.backendConfig.populateDbProperties(backendConfig,
                                                            supportedProperties);

  return {
    config: backendConfig,
    props: properties
  };
}

function createExitCall(agent, client, time, args, props) {
  var command = args.length > 0 ? args[0] : undefined;
  var params = args.length > 1 && Array.isArray(args[1]) ? args[1] : undefined;

  return agent.profiler.createExitCall(time, {
    exitType: 'EXIT_DB',
    backendName: 'PostgreSQL',
    backendConfig: props.config,
    identifyingProperties: props.props,
    command: truncate(agent.profiler, command),
    commandArgs: agent.profiler.truncate(params),
    user: client.user,
    stackTrace: agent.profiler.stackTrace(),
    isSql: true
  });
}

function truncate(profiler, str) {
  if(str && typeof(str) === 'object') {
    str = str.text;
  }

  return profiler.truncate(str);
}
