/*
Copyright (c) AppDynamics, Inc., and its affiliates
2015
All Rights Reserved
*/
'use strict';

var url = require('url');

function HttpProbe(agent) {
  this.agent = agent;
  this.statusCodeConfigs = undefined;
  this.packages = ['http', 'https'];
  this.init();

  this.delayedCallbackQueue = [];
}
exports.HttpProbe = HttpProbe;

HttpProbe.prototype.init = function() {
  var self = this;

  self.agent.on('configUpdated', function() {
    self.statusCodesConfig = self.agent.configManager.getConfigValue('errorConfig.httpStatusCodes');
  });
};

HttpProbe.prototype.finalizeTransaction = function(err, profiler, time, transaction, res) {
  if(!time.done()) return;

  transaction.error = res.error || err;
  transaction.statusCode = (transaction.error && transaction.error.statusCode) ||
                           (res && res.statusCode) ||
                           500;
  transaction.stackTrace = profiler.formatStackTrace(transaction.error);

  if (!transaction.error) {
    var statusCodeConfig = this.getHttpStatusCodeConfig(transaction.statusCode);
    if (statusCodeConfig) {
      if (statusCodeConfig.enabled) {
        transaction.error = new Error(statusCodeConfig.description);
      }
    }
    else if ((transaction.statusCode < 200) || (transaction.statusCode >= 400)) {
      transaction.error = new Error("Error code, " + transaction.statusCode + ", no further details");
    }
  }

  profiler.endTransaction(time, transaction);
};

HttpProbe.prototype.getHttpStatusCodeConfig = function(statusCode) {
  if (!this.statusCodesConfig) {
    return undefined;
  }

  for (var i = 0, length = this.statusCodesConfig.length; i < length; ++i) {
    var statusCodeConfig = this.statusCodesConfig[i];
    if (statusCode >= statusCodeConfig.lowerBound &&
        statusCode <= statusCodeConfig.upperBound) {
      return statusCodeConfig;
    }
  }

  return undefined;
};

function createBTCallback(agent, profiler, time, transaction, req, res, thread, callback, self, origSelf, origArgs) {
    var didRun = false;
    var threadId = thread.current();

    // Node 0.8: need to ensure request isn't consumed
    // before delayed handler gets run
    if (agent.processInfo.isv0_8) {
      req.pause();
    }

    return function () {
        if (didRun) return;
        didRun = true;

        // Node 0.8: safe to resume the request now
        // we're ready to process it
        if (agent.processInfo.isv0_8) {
          req.resume();
        }

        var oldThreadId = thread.current();
        thread.resume(threadId);
        try {
            callback = agent.proxy.wrapWithThreadProxyIfEnabled(callback);
            callback.apply(origSelf, origArgs);
        } catch (e) {
            self.finalizeTransaction(e, profiler, time, transaction, res);
            throw e;
        } finally {
            thread.resume(oldThreadId);
        }
    };
}

HttpProbe.prototype.__createRequestHandler = function (callback, isHTTPs) {
    var self = this;

    return function (req, res) {
        var profiler = self.agent.profiler;
        var proxy = self.agent.proxy;
        var time = profiler.time(true);

        self.agent.metricsManager.addMetric('HTTP', 'Incoming Connection Count', 1, 'count', 'sum');

        var transaction = profiler.startTransaction(time, req, 'NODEJS_WEB');
        req.__appdThreadId = transaction.threadId;

        transaction.url = req.url;
        transaction.method = req.method;
        transaction.requestHeaders = req.headers;

        if(self.agent.eum.enabled && !transaction.corrHeader) {
          proxy.before(res, 'writeHead', function(obj, args) {
            var eumCookie = self.agent.eum.newEumCookie(transaction, req, obj, isHTTPs);
            eumCookie.build();
          });
        }

        proxy.after(res, 'end', function(obj, args) {
            self.finalizeTransaction(null, profiler, time, transaction, res);
        });

        if (self.agent.opts.btEntryPointDelayDisabled) {
            try {
                return callback.apply(this, arguments);
            } catch (e) {
                self.finalizeTransaction(e, profiler, time, transaction, res);
                throw e;
            }
        }

        var delayedCallback = createBTCallback(self.agent,
                                               profiler,
                                               time,
                                               transaction,
                                               req, res,
                                               self.agent.thread,
                                               callback,
                                               self,
                                               this,
                                               arguments);

        transaction.once('btInfoResponse', delayedCallback);
        self.delayedCallbackQueue.push({ts: Date.now(), func: delayedCallback});
    };
};

HttpProbe.prototype.setHttpDefaults = function(locals, spec, protocol) {
    if(typeof(spec) === 'string') {
      locals.opts = url.parse(spec);
    }
    else {
      locals.opts = spec;
    }

    locals.opts.hostname = locals.opts.hostname || locals.opts.host || 'localhost';
    locals.opts.port = locals.opts.port || (protocol === 'https' ? 443 : 80);
    locals.opts.path = locals.opts.path || '/';
};

HttpProbe.prototype.attach = function(obj, moduleName) {
  var self = this;

  if(obj.__appdynamicsProbeAttached__) return;
  obj.__appdynamicsProbeAttached__ = true;


  var timer = self.agent.timers.startTimer(100, true, function() {
    var now = Date.now();

    while(self.delayedCallbackQueue.length > 0) {
      if(self.delayedCallbackQueue[0].ts < now - 10) {
        var delayedCallbackInfo = self.delayedCallbackQueue.shift();
        delayedCallbackInfo.func.call(this);
      }
      else {
        break;
      }
    }
  });

  var profiler = self.agent.profiler;
  var proxy = self.agent.proxy;

  self.isHTTPs = obj.Agent && (obj.Agent.prototype.defaultPort == 443);

  // server probe
  self.agent.proxy.before(obj.Server.prototype, ['on', 'addListener'], function(obj, args) {
    if(args[0] !== 'request') return;

    if(obj.__httpProbe__) return;
    obj.__httpProbe__ = true;

    var cbIndex = args.length -1 ;

    args[cbIndex] = self.__createRequestHandler(args[cbIndex], moduleName === 'https');
  });


  // client probe
  function clientCallback(locals) {
    if(!locals.time.done()) return;

    var exitCall = locals.exitCall;
    var error = locals.error;

    if(exitCall) {
      if(locals.res) {
        exitCall.responseHeaders = locals.res.headers;
        exitCall.statusCode = ~~locals.res.statusCode;
        if((!error) && ((exitCall.statusCode < 200) || (exitCall.statusCode >= 400))) {
          error = new Error("Error code, " + exitCall.statusCode + ", no further details");
        }
      }

      profiler.addExitCall(locals.time, exitCall, error);
    }
  }

  // support 0.11.x and further
  if(obj.globalAgent && obj.globalAgent.request) {
    obj = obj.globalAgent;
  }

  proxy.around(obj, 'request', function(obj, args, locals) {
    self.agent.metricsManager.addMetric('HTTP', 'Outgoing Connection Count', 1, 'count', 'sum');

    self.setHttpDefaults(locals, args[0], moduleName);
    locals.time = profiler.time();

    if (!args[0].appdIgnore) { // (ignore internal HTTP calls, e.g. to Analytics Agent)
      var host = locals.opts.hostname;
      var port = locals.opts.port;
      var path = locals.opts.path;

      var supportedProperties = {
        'HOST': host,
        'PORT': port
      };

      // only populate the query string if it's required for naming or identity
      if (self.agent.backendConfig.isParsedUrlRequired()) {
        var parsedUrl = url.parse(path);
        supportedProperties.URL = parsedUrl.pathname;
        supportedProperties['QUERY STRING'] = parsedUrl.query;
      }

      var backendConfig = self.agent.backendConfig.getHttpConfig(supportedProperties);
      // if there's no backend config (OOTB or custom), then ignore this exit call
      if (!backendConfig) {
        return;
      }

      var props = self.agent.backendConfig.populateHttpProperties(backendConfig, supportedProperties);

      locals.exitCall = profiler.createExitCall(locals.time, {
        exitType: 'EXIT_HTTP',
        backendName: 'HTTP',
        backendConfig: backendConfig,
        identifyingProperties: props,
        stackTrace: profiler.stackTrace(),
        group: (locals.opts.method || 'GET'),
        method: locals.opts.method,
        command: host + ':' + port + path,
        requestHeaders: locals.opts.headers,
        category: ((locals.opts.method === 'POST' || locals.opts.method === 'PUT') ? "write" : "read"),
        protocol: moduleName
      });
    }

    var hasCallback = proxy.callback(args, -1, function(obj, args) {
      var res = locals.res = args[0];
      proxy.before(res, ['on', 'addListener'], function(obj, args) {
        // workaround for end event
        if(args[0] === 'data' && obj.on !== undefined) {
          obj.on('end', function() {});
        }

        if(args[0] !== 'end') return;

        clientCallback(locals);
      });
    }, function(obj, args, ret) {
      if(locals.res && locals.res.listenerCount && locals.res.listenerCount('end') === 0) {
        clientCallback(locals);
      }
    });

    if(!hasCallback) {
      clientCallback(locals);
    }

  },
  function(obj, args, ret, locals) {
    var writeOnce = false;

    proxy.before(ret, ['write', 'end'], function(obj, args) {
      if(!writeOnce) {
        writeOnce = true;
      }
      else {
        return;
      }

      if(locals.exitCall && locals.exitCall.backendConfig.correlationEnabled) {
        var transaction = profiler.getTransaction(locals.exitCall.threadId);
        if (transaction) {
          var corrHeader = self.agent.correlation.newCorrelationHeader();
          corrHeader.build(transaction, locals.exitCall);
          obj.setHeader(self.agent.correlation.HEADER_NAME, corrHeader.getStringHeader());

          // to check if we are ignoring possible snapshot request from btInfoResponse
          if(!transaction.ignore && !transaction.btInfoResponse) {
            self.agent.logger.log("btInfoResponse is not yet available");
          }
        }
      }
    });

    proxy.before(ret, ['on', 'addListener'], function(obj, args) {
      if(args[0] == 'response') {
        proxy.callback(args, -1, function(obj, args) {
          locals.res = args[0];
          clientCallback(locals);
        });
      }
      else if(args[0] == 'error') {
        proxy.callback(args, -1, function(obj, args) {
          locals.error = args[0];
          clientCallback(locals);
        });
      }
    });
  });
};
