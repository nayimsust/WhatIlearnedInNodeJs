/*
Copyright (c) AppDynamics, Inc., and its affiliates
2015
All Rights Reserved
*/
'use strict';



function MongodbProbe(agent) {
  this.agent = agent;

  this.packages = ['mongodb', 'mongodb-core'];
}
exports.MongodbProbe = MongodbProbe;



MongodbProbe.prototype.attach = function(obj, name) {
  var self = this;
  var proxy = self.agent.proxy;
  var profiler = self.agent.profiler;

  if(obj.__appdynamicsProbeAttached__) return;
  obj.__appdynamicsProbeAttached__ = true;

  if (name == 'mongodb-core') {
    // driver 2.x
    var commands = [
      'cursor', 'insert', 'update', 'remove'
    ];

    // queries via a cursor find command must be reported after they complete:
    proxy.before(obj.Cursor.prototype, 'next', function(obj, args) {
      proxy.callback(args, -1, function(obj_, args) {
        if (args[1] === null) {
          if (!(obj.server && obj.server.__appd_exitcall_info)) return;

          var time = obj.server.__appd_exitcall_info.time;
          var exitCall = obj.server.__appd_exitcall_info.exitCall;

          self.addExitCall(time, exitCall, args);
        }
      });
    });

    commands.forEach(function(command) {
      var commandName = command == 'cursor' ? 'find' : command;

      proxy.before(obj.Server.prototype, command, function(obj, args) {
        var commandArgs;
        var category;
        var exitCall;
        var time;
        var opts = {};
        var query = '';

        if (command == 'cursor' && !args[1].find) return;

        var serverPool = self.getServerPool(obj.s);

        if (serverPool.length) {
          opts = {};
          if (args[1] && args[1].query) {
            query = profiler.truncate(JSON.stringify(args[1].query));
            Object.keys(args[1]).forEach(function(key) {
              if (key !== 'query') {
                opts[key] = args[1][key];
              }
            });
          }

          commandArgs = {
                databaseName: args[0].split('.')[0],
                collectionName: args[0].split('.')[1],
                query: query,
                queryOptions: opts,
                numberToSkip: opts.skip,
                numberToReturn: opts.limit
          };

          if(obj.s.auths && obj.s.auths.length > 0) {
            commandArgs.auth = obj.s.auths[0];
          }

          if (commandName == 'find') {
            category = "read";
          } else {
            category = "write";
          }

          time = profiler.time();

          exitCall = self.createExitCall(time, serverPool, 
            commandName, commandArgs, category, 
            profiler.stackTrace());
        }

        if (commandName == 'find') {
          // stash exit call for later processing
          obj.__appd_exitcall_info = {
            time: time,
            exitCall: exitCall
          };
        } else {
          proxy.callback(args, -1, function(obj, args) {
            self.addExitCall(time, exitCall, args);
          });
        }
      });
    });
  }

  if (obj.Db && obj.Db.prototype && obj.Db.prototype._executeQueryCommand) {
    // driver 1.x
    var internalCommands = [
      '_executeQueryCommand',
      '_executeInsertCommand',
      '_executeUpdateCommand',
      '_executeRemoveCommand'
    ];

    var commandMap = {
      '_executeQueryCommand': 'find',
      '_executeInsertCommand': 'insert',
      '_executeUpdateCommand': 'update',
      '_executeRemoveCommand': 'remove'
    };

    internalCommands.forEach(function(internalCommand) {
      var commandName = commandMap[internalCommand] || internalCommand;

      proxy.before(obj.Db.prototype, internalCommand, function(obj, args) {
        var command = (args && args.length > 0) ? args[0] : undefined;
        var commandArgs;
        var exitCall;
        var time;

        if(command && command.db) {
          var serverPool = self.getServerPool(command.db);
          var category;

          if (serverPool.length) {
            commandArgs = {
              databaseName: command.db.databaseName,
              collectionName: command.collectionName,
              query: command.query ? profiler.truncate(JSON.stringify(command.query)) : '',
              queryOptions: command.queryOptions,
              numberToSkip: command.numberToSkip,
              numberToReturn: command.numberToReturn
            };

            if(command.db.auths && command.db.auths.length > 0) {
              commandArgs.auth = command.db.auths[0];
            }

            if(internalCommand === '_executeQueryCommand') {
              category = "read";
            }
            else {
              category = "write";
            }

            time = profiler.time();

            exitCall = self.createExitCall(time, serverPool, 
              commandName, commandArgs, category, 
              profiler.stackTrace());
          }
        }

        proxy.callback(args, -1, function(obj, args) {
          self.addExitCall(time, exitCall, args);
        });
      });
    });
  }
};

MongodbProbe.prototype.getServerPool = function(db) {
  var serverPool = [];

    var serverConfig = db && db.serverConfig || db.serverDetails;
    if(serverConfig) {
      if(serverConfig.s && serverConfig.s.host && serverConfig.s.port) {
        serverPool.push(serverConfig.s.host + ':' + serverConfig.s.port);
      }
      else if(serverConfig.host && serverConfig.port) {
        serverPool.push(serverConfig.host + ':' + serverConfig.port);
      }
      else if(Array.isArray(serverConfig.servers)) {
        serverConfig.servers.forEach(function(server) {
          serverPool.push(server.host + ':' + server.port);
        });
      }
    }

    if (serverPool.length) {
      serverPool = serverPool.sort();
    }

    return serverPool;
};

MongodbProbe.prototype.createExitCall = function(time, serverPool, commandName, commandArgs, category, stackTrace) {
  var profiler = this.agent.profiler;

  var props = {
    'SERVER POOL': serverPool.join('\n'),
    DATABASE : commandArgs.databaseName,
    VENDOR : "MONGODB"
  };

  return this.agent.profiler.createExitCall(time, {
    exitType: 'EXIT_DB',
    backendConfig: {
      customConfig: false
    },
    backendName: 'MongoDB',
    identifyingProperties: props,
    category: category,
    command: commandName,
    commandArgs: commandArgs,
    stackTrace: stackTrace,
    label: serverPool[serverPool.length - 1] + ' - MONGODB',
    vendor: "MONGODB"
  });
};

MongodbProbe.prototype.addExitCall = function(time, exitCall, args) {
  if (exitCall) {
    if(!time.done()) return;
    var error = this.agent.proxy.getErrorObject(args);
    this.agent.profiler.addExitCall(time, exitCall, error);
  }
};
