/*
Copyright (c) AppDynamics, Inc., and its affiliates
2015
All Rights Reserved
*/
/* global process, require, exports */
'use strict';

var os = require('os');
var fs = require('fs');
var path = require('path');
var cp = require('child_process');
var cluster = require('cluster');
var jre = require('appdynamics-jre');
var proxy = require('appdynamics-proxy');

/*
 * Autolaunching:
 * - The proxy is not launched if "proxyAutolaunchDisabled" option is set
 *   to false.
 * - Only master node autolaunches proxy, i.e. in case of cluster only
 *   one proxy instance is autolaunched.
 *
 * StartNodeRequest:
 * - In case of cluster, only workers send StartNodeRequest
 * - For the cases where cluster master cannot be identified there
 *   is a "monitorClusterMaster" option, which is false by default
 * - nodeIndex parameter is calculated by master node, which writes
 *   files for each worker to pick up their indexes from
 */

function ProxyLauncher(agent) {
  this.agent = agent;

  this.indexDir = undefined;

  this.processProcess = undefined;
  this.termHandler = undefined;
  this.uncaughtHandler = undefined;

}
exports.ProxyLauncher = ProxyLauncher;


ProxyLauncher.prototype.init = function() {
  var self = this;

  self.indexDir = self.agent.tmpDir + '/index';

  self.agent.once('nodeIndex', function(nodeIndex) {
    self.uncaughtHandler = function(e) {
      self.agent.logger.log('uncaughtException:');
      self.agent.logger.error(e);
      self.agent.logger.dumpCapture();

      self.agent.proxyTransport.sendAppException(e);

      var listeners = process.listeners('uncaughtException');
      if(listeners && listeners.length == 1) {
        if (self.termHandler) {
           self.termHandler();
        }
      }
    };
    process.on('uncaughtException', self.uncaughtHandler);

    self.agent.emit('launchProxy', nodeIndex);
  });

  self.agent.on('launchProxy', function(nodeIndex, force) {
    if(!self.agent.opts.proxyAutolaunchDisabled) {
      if(cluster.isMaster) {
        self.agent.logger.log('launching proxy from master node ' + nodeIndex);
        self.startProxy(nodeIndex, force);
      }

      // wait for proxy to launch
      self.agent.timers.setTimeout(function() {
        self.agent.emit('proxyStarted', nodeIndex);
      }, 5000);
    }
    else {
      // need some time to be able to identify cluster master
      // by checking if any workers have been forked
      self.agent.timers.setTimeout(function() {
        self.agent.emit('proxyStarted', nodeIndex);
      }, 1000);
    }
  });
};

ProxyLauncher.prototype.start = function() {
  var self = this;

  if(cluster.isMaster) {
    var nodeIndex = self.agent.opts.nodeIndex || 0;
    self.agent.emit('nodeIndex', nodeIndex);
  }
  else {
    self.agent.timers.setTimeout(function() {
      self.readNodeIndex(function(nodeIndex) {
        if(nodeIndex !== null) {
          self.agent.emit('nodeIndex', nodeIndex);
        }
        else {
          self.agent.timers.setTimeout(function() {
            self.readNodeIndex(function(nodeIndex) {
              if(nodeIndex !== null) {
                self.agent.emit('nodeIndex', nodeIndex);
              }
              else {
                // return pid instead of index if indexing is not available,
                // e.g. this process is forked from a worker
                self.agent.emit('nodeIndex', process.pid);
              }
            });
          }, 4000);
        }
      });
    }, 1000);
  }
};

ProxyLauncher.prototype.readNodeIndex = function(callback) {
  var self = this;

  var callbackCalled = false;
  function callbackOnce(ret) {
    if(!callbackCalled) {
      callbackCalled = true;
      callback(ret);
    }
  }

  fs.exists(self.indexDir, function(exists) {
    if(!exists) return;

    fs.readdir(self.indexDir, function(err, indexFiles) {
      if(err) return self.agent.logger.error(err);

      indexFiles.forEach(function(indexFile) {
        var nodeIndex = parseInt(indexFile.split('.')[0]);
        if(!isNaN(nodeIndex)) {
          fs.readFile(self.indexDir + '/' + indexFile, function(err, pid) {
            if(err) return self.agent.logger.error(err);

            if(pid == process.pid) {
              callbackOnce(nodeIndex);
            }
          });
        }
      });
    });
  });

  self.agent.timers.setTimeout(function() {
    callbackOnce(null);
  }, 2000);
};

ProxyLauncher.prototype.isProxyRunning = function(proxyPidFile) {
  if (fs.existsSync(proxyPidFile)) {
    try {
      var proxyPid = fs.readFileSync(proxyPidFile, 'utf-8');
      process.kill(proxyPid, 0);
      return true;
    } catch (e) {
      // proxy process went away; clean up stale pid file
      fs.unlinkSync(proxyPidFile);
    }
  }

  return false;
};

ProxyLauncher.prototype.storeProxyPID = function(proxyPidFile, pid) {
  fs.writeFileSync(proxyPidFile, pid);
};

ProxyLauncher.prototype.clearProxyPID = function(proxyPidFile) {
  try {
    fs.unlinkSync(proxyPidFile);
  } catch (e) {
    this.agent.logger.log('unable to delete proxy PID file: ' + e.message);
  }
};

ProxyLauncher.prototype.startProxy = function(nodeIndex, force) {
  var self = this;

  var opts = self.agent.opts;

  var proxyDir = proxy.dir;
  var proxyCommDir = self.agent.proxyCtrlDir;
  var proxyLogsDir = self.agent.proxyLogsDir;
  var proxyRuntimeDir = self.agent.proxyRuntimeDir;
  var proxyPidFile = path.join(proxyRuntimeDir, 'proxy.pid');

  if (!force && self.isProxyRunning(proxyPidFile)) {
    self.agent.logger.log('reusing existing proxy process');
    return;
  }

  self.clearProxyDirectories(function() {
    var proxyArgs = [
        '-d', proxyDir,
        '-r', proxyRuntimeDir,
        '-j', jre.dir
      ];
    proxyArgs.push("--");
    if (self.agent.isWindows) {
      proxyArgs.push(
        proxyLogsDir,
        opts.proxyCommPort || 10101
      );
    } else {
      proxyArgs.push(
        proxyCommDir,
        proxyLogsDir,
        '-Dregister=false'
      );
    }

    var proxyOutput;

    self.agent.logger.log("proxyArgs = " + JSON.stringify(proxyArgs, null, " "));

    if(self.agent.opts.proxyOutEnabled) {
        proxyOutput = fs.openSync(proxyLogsDir + "/proxy.out", 'w');
        self.proxyProcess = self.spawn(proxyDir, proxyArgs, ['ignore', proxyOutput, proxyOutput]);
    }
    else {
        self.proxyProcess = self.spawn(proxyDir, proxyArgs, 'ignore');
    }

    self.storeProxyPID(proxyPidFile, self.proxyProcess.pid);

    self.agent.logger.log("Proxy logging to: " + proxyLogsDir);
    self.agent.logger.log("Proxy spawned!");
    self.proxyProcess.unref();
    proxyOutput = undefined;

    self.termHandler = function () {
      self.agent.logger.log("Node Agent Terminated -- "+ JSON.stringify(arguments));
      self.proxyProcess.kill('SIGKILL');
      self.clearProxyControlDirectory();
      self.clearProxyPID(proxyPidFile);
      self.agent.emit('proxyKilled');
      process.removeListener('SIGTERM', self.termHandler);
      process.removeListener('SIGINT', self.termHandler);
      process.removeListener('uncaughtException', self.uncaughtHandler);
      process.kill(process.pid, 'SIGTERM');
    };

    process.on('SIGTERM', self.termHandler);
    process.on('SIGINT', self.termHandler);
  });
};

ProxyLauncher.prototype.clearProxyDirectories = function(cb) {
  var proxyCommDir = this.agent.proxyCtrlDir;
  var proxyLogsDir = this.agent.proxyLogsDir;
  cp.exec('rm -rf ' + proxyCommDir + '/* ' + proxyLogsDir + '/*', cb);
};

ProxyLauncher.prototype.clearProxyControlDirectory = function() {
  cp.exec('rm -rf ' + this.agent.proxyCtrlDir + '/*');
};

ProxyLauncher.prototype.spawn = function(proxyDir, proxyArgs, input) {
  var proxyCmd = "runProxy";
  if (this.agent.isWindows) {
    proxyCmd += ".cmd";
  } else {
    proxyCmd = './' + proxyCmd;
  }
  this.agent.logger.log("cmdLine = " + path.join(proxyDir, proxyCmd) + " " + proxyArgs.join(" "));
  return cp.spawn(proxyCmd, proxyArgs, {
    detached: false, stdio: input, cwd: proxyDir
  });
};
