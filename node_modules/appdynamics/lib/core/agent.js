/*
Copyright (c) AppDynamics, Inc., and its affiliates
2015
All Rights Reserved
*/
'use strict';

var os = require('os');
var fs = require('fs');
var util = require('util');
var path = require('path');
var cluster = require('cluster');
var EventEmitter = require('events').EventEmitter;
var crypto = require('crypto');

var Logger = require('./logger').Logger;
var Timers = require('./timers').Timers;
var System = require('./system').System;
var Proxy = require('./proxy').Proxy;
var Thread = require('./thread').Thread;
var Utils = require('./utils').Utils;
var AnalyticsReporter = require('../transactions/analytics-reporter').AnalyticsReporter;
var MetricsManager = require('../metrics/metrics-manager').MetricsManager;
var ProcessInfo = require('../process/process-info').ProcessInfo;
var ProcessScanner = require('../process/process-scanner').ProcessScanner;
var ProcessStats = require('../process/process-stats').ProcessStats;
var InstanceTracker = require('../process/instance-tracker').InstanceTracker;
var ProxyLauncher = require('../proxy/proxy-launcher').ProxyLauncher;
var ProxyTransport = require('../proxy/proxy-transport').ProxyTransport;
var StringMatcher = require('../proxy/string-matcher').StringMatcher;
var ExpressionEvaluator = require('../proxy/expression-evaluator').ExpressionEvaluator;
var ConfigManager = require('../transactions/config-manager').ConfigManager;
var TransactionRegistry = require('../transactions/transaction-registry').TransactionRegistry;
var TransactionNaming = require('../transactions/transaction-naming').TransactionNaming;
var TransactionReporter = require('../transactions/transaction-reporter').TransactionReporter;
var TransactionRules = require('../transactions/transaction-rules').TransactionRules;
var Correlation = require('../transactions/correlation').Correlation;
var DataCollectors = require('../transactions/data-collectors').DataCollectors;
var Eum = require('../transactions/eum').Eum;
var Profiler = require('../profiler/profiler').Profiler;
var NamedTransactions = require('../profiler/named-transactions').NamedTransactions;
var CustomTransaction = require('../profiler/custom-transaction').CustomTransaction;
var GCStats = require('../v8/gc-stats').GCStats;
var CpuProfiler = require('../v8/cpu-profiler').CpuProfiler;
var HeapProfiler = require('../v8/heap-profiler').HeapProfiler;
var BackendConfig = require('../proxy/backend-config').BackendConfig;
var agentVersion = require('../../appdynamics_version.json');
var appDNativeLoader = require('appdynamics-native');

function Agent() {
  this.isWindows = os.platform() == 'win32';
  this.rootTmpDir = '/tmp/appd';
  if(this.isWindows) {
    this.rootTmpDir = os.tmpdir();
  } else if(!fs.existsSync('/tmp')) {
    this.rootTmpDir = './tmp/appd'; // Heroku case
  }

  this.logsDir = '/var/log/appdynamics';
  if(!fs.existsSync('/var/log')) {
    this.logsDir = './log/appdynamics'; // Heroku case
  }

  this.initialized = false;
  this.version = agentVersion.version;
  this.nextId = Math.round(Math.random() * Math.pow(10, 6));
  this.appdNative = undefined;

  // predefine options
  this.debug = false;
  this.precompiled = undefined;

  this.proxyCtrlDir = undefined;
  this.proxyLogsDir = undefined;
  this.proxyRuntimeDir = undefined;

  EventEmitter.call(this);


  // create modules
  this.logger = new Logger(this);
  this.timers = new Timers(this);
  this.system = new System(this);
  this.proxy = new Proxy(this);
  this.thread = new Thread(this);
  this.utils = new Utils(this);
  this.analyticsReporter = new AnalyticsReporter(this);
  this.metricsManager = new MetricsManager(this);
  this.processInfo = new ProcessInfo(this);
  this.processScanner = new ProcessScanner(this);
  this.processStats = new ProcessStats(this);
  this.instanceTracker = new InstanceTracker(this);
  this.proxyLauncher = new ProxyLauncher(this);
  this.proxyTransport = new ProxyTransport(this);
  this.stringMatcher = new StringMatcher(this);
  this.expressionEvaluator = new ExpressionEvaluator(this);
  this.configManager = new ConfigManager(this);
  this.transactionRegistry = new TransactionRegistry(this);
  this.transactionNaming = new TransactionNaming(this);
  this.transactionReporter = new TransactionReporter(this);
  this.transactionRules = new TransactionRules(this);
  this.correlation = new Correlation(this);
  this.dataCollectors = new DataCollectors(this);
  this.eum = new Eum(this);
  this.profiler = new Profiler(this);
  this.namedTransactions = new NamedTransactions(this);
  this.customTransaction = new CustomTransaction(this);
  this.gcStats = new GCStats(this);
  this.cpuProfiler = new CpuProfiler(this);
  this.heapProfiler = new HeapProfiler(this);
  this.backendConfig = new BackendConfig(this);
}

util.inherits(Agent, EventEmitter);

Agent.prototype.recursiveMkDir = function (dir) {
  var dirsToMake = [];
  var currDir = path.normalize(dir);
  var parentDir = path.dirname(currDir);
  while (true) {
    if (fs.existsSync(currDir))
      break;
    dirsToMake.push(currDir);
    currDir = parentDir;
    parentDir = path.dirname(currDir);
    if (currDir == parentDir)
      break;
  }

  while (dirsToMake.length) {
    currDir = dirsToMake.pop();
    if (!fs.existsSync()) {
      fs.mkdirSync(currDir);
    }
  }
};

Agent.computeTmpDir = function (rootTmpDir,
                                controllerHost,
                                controllerPort,
                                appName,
                                tierName,
                                nodeName) {
  var stringToHash = controllerHost.toString() + ',' +
                    controllerPort.toString() + ',' +
                    appName.toString() + ',' +
                    tierName.toString() + ',' +
                    nodeName.toString();
  // We don't need cryptographic security here,
  // just a unique, predictable fixed length directory name.
  var md5 = crypto.createHash('md5');
  md5.update(stringToHash);
  return path.join(rootTmpDir, md5.digest('hex'));
};

Agent.resolveProxyCtrlDir = function (defaultDir, opts) {
  var dirFromOpts = opts.proxyCtrlDir;
  if (!dirFromOpts) {
    return defaultDir;
  }
  dirFromOpts = path.normalize(dirFromOpts.toString());
  if (path.dirname(dirFromOpts) == dirFromOpts) {
    // Eeeck!!!
    // Looks like someone tried to specify the root directory as
    // the proxy communication directory.   There is a really unsafe
    // rm -rf in proxy-launcher that will do a:
    // rm -rf //* if the proxy communication directory is '/'.
    return defaultDir;
  }
  return dirFromOpts;
};

Agent.prototype.init = function(opts) {
  var self = this;

  if (self.initialized)
    return;

  self.initialized = true;

  self.initializeOpts(opts);

  self.debug = opts.debug;
  self.precompiled = opts.precompiled === undefined || opts.precompiled;

  if(self.opts.excludeAgentFromCallGraph === undefined) {
    self.opts.excludeAgentFromCallGraph = true;
  }

  if (self.opts.rootTmpDir) {
    self.rootTmpDir = self.opts.rootTmpDir;
  }

  // Temp directory
  if(self.opts.tmpDir) {
    self.tmpDir = self.opts.tmpDir;
  }
  else {
    self.tmpDir = Agent.computeTmpDir(self.rootTmpDir,
                                      self.opts.controllerHostName,
                                      self.opts.controllerPort,
                                      self.opts.applicationName,
                                      self.opts.tierName,
                                      self.opts.nodeName);
  }

  self.recursiveMkDir(self.tmpDir);

  // Initialize logger first.
  self.logger.init(self.debug);
  self.logger.startCapture();

  var proxyTmpDir = path.join(self.tmpDir, 'proxy');

  self.proxyCtrlDir = Agent.resolveProxyCtrlDir(path.join(proxyTmpDir, 'c'), opts);

  self.recursiveMkDir(self.proxyCtrlDir);

  self.proxyLogsDir = path.join(proxyTmpDir, 'l');
  self.recursiveMkDir(self.proxyLogsDir);

  self.proxyRuntimeDir = path.join(proxyTmpDir, 'r');
  self.recursiveMkDir(self.proxyRuntimeDir);


  self.logger.log("agent.tmpDir = " + JSON.stringify(self.tmpDir));
  self.logger.log("agent.proxyCtrlDir = " + JSON.stringify(self.proxyCtrlDir));

  self.setMaxListeners(15);

  // Load native extention
  self.loadNativeExtention();

  // Initialize core modules first.
  self.timers.init();
  self.system.init();
  self.proxy.init();
  self.thread.init();
  self.utils.init();

  // Initialize data sender.
  self.proxyLauncher.init();
  self.proxyLauncher.start();
  self.proxyTransport.init();
  self.stringMatcher.init();
  self.expressionEvaluator.init();
  self.configManager.init();
  self.transactionRegistry.init();
  self.transactionNaming.init();
  self.transactionReporter.init();
  self.transactionRules.init();
  self.correlation.init();
  self.dataCollectors.init();
  self.eum.init();

  // Metrics aggregator should be initialize before
  // metric senders.
  self.metricsManager.init();

  // Initialize the rest.
  self.analyticsReporter.init();
  self.processInfo.init();
  self.processScanner.init();
  self.processStats.init();
  self.instanceTracker.init();
  self.profiler.init();
  self.namedTransactions.init(opts.namedTransactions);
  self.customTransaction.init();
  self.gcStats.init();
  self.cpuProfiler.init();
  self.heapProfiler.init();
  self.backendConfig.init();

  // Prepare probes.
  self.loadProbes();

  try {
    self.emit('session');
  }
  catch(err) {
    self.logger.error(err);
  }
};

Agent.prototype.initializeOpts = function(opts) {
  var self = this;
  opts = opts || {};

  self.opts = opts;
  if (self.opts.controllerHostName === undefined) {
    self.opts.controllerHostName = process.env.APPDYNAMICS_CONTROLLER_HOST_NAME;
  }
  if (self.opts.controllerPort === undefined) {
    self.opts.controllerPort = process.env.APPDYNAMICS_CONTROLLER_PORT;
  }
  if (self.opts.controllerSslEnabled === undefined) {
    self.opts.controllerSslEnabled = process.env.APPDYNAMICS_CONTROLLER_SSL_ENABLED;
  }
  if (self.opts.accountName === undefined) {
    self.opts.accountName = process.env.APPDYNAMICS_AGENT_ACCOUNT_NAME;
  }
  if (self.opts.accountAccessKey === undefined) {
    self.opts.accountAccessKey = process.env.APPDYNAMICS_AGENT_ACCOUNT_ACCESS_KEY;
  }
  if (self.opts.applicationName === undefined) {
    self.opts.applicationName = process.env.APPDYNAMICS_AGENT_APPLICATION_NAME;
  }
  if (self.opts.tierName === undefined) {
    self.opts.tierName = process.env.APPDYNAMICS_AGENT_TIER_NAME;
  }
  if (self.opts.nodeName === undefined) {
    self.opts.nodeName = process.env.APPDYNAMICS_AGENT_NODE_NAME;
  }
};

Agent.prototype.profile = Agent.prototype.init;


Agent.prototype.loadProbes = function() {
  var self = this;

  // Dynamic probes.
  var probeCons = [];
  probeCons.push(require('../probes/cluster-probe').ClusterProbe);
  probeCons.push(require('../probes/disk-probe').DiskProbe);
  probeCons.push(require('../probes/http-probe').HttpProbe);
  probeCons.push(require('../probes/memcached-probe').MemcachedProbe);
  probeCons.push(require('../probes/mongodb-probe').MongodbProbe);
  probeCons.push(require('../probes/mysql-probe').MysqlProbe);
  probeCons.push(require('../probes/net-probe').NetProbe);
  probeCons.push(require('../probes/pg-probe').PgProbe);
  probeCons.push(require('../probes/redis-probe').RedisProbe);
  probeCons.push(require('../probes/ioredis-probe').IoredisProbe);
  probeCons.push(require('../probes/socket.io-probe').SocketioProbe);

  var packageProbes = {};
  probeCons.forEach(function(ProbeCon) {
    var probe = new ProbeCon(self);
    probe.packages.forEach(function(pkg) {
      packageProbes[pkg] = probe;
    });
  });

  // on demand probe attaching
  self.proxy.after(module.__proto__, 'require', function(obj, args, ret) {
    var probe = packageProbes[args[0]];
    if(probe) {
      probe.attach(ret, args[0]);
    }
  });

  // Trying to preattaching probles.
  for(var name in packageProbes) {
    try {
      if(require.main) {
        require.main.require(name);
        self.logger.log('found ' + name + ' module');
      }
    }
    catch(err) {
      // ignore exceptions
    }
  }


  // Explicit probes.
  var ProcessProbe = require('../probes/process-probe').ProcessProbe;
  new ProcessProbe(self).attach(process);
  var GlobalProbe = require('../probes/global-probe').GlobalProbe;
  new GlobalProbe(self).attach(global);
};


Agent.prototype.loadNativeExtention = function() {
    var self = this;

    if (!self.appdNative)
        self.appdNative = appDNativeLoader.load(this);
};



Agent.prototype.getNextId = function() {
  return this.nextId++;
};


Agent.prototype.destroy = function() {
  try {
    this.emit('destroy');
  }
  catch(err) {
    this.logger.error(err);
  }

  this.removeAllListeners();
};

Agent.prototype.getTransaction = function(req) {
  var threadId, txn;

  if(!this.initialized) return;

  threadId = req && req.__appdThreadId;
  txn = threadId && this.profiler.getTransaction(threadId);

  return txn && !txn.ignore && this.customTransaction.join(req, txn);
};

Agent.prototype.startTransaction = function(transactionInfo) {
  if(!this.initialized) return;

  return this.customTransaction.start(transactionInfo);
};

Agent.prototype.parseCorrelationInfo = function(source) {
  var corrHeader = this.correlation.newCorrelationHeader();
  if (typeof(source) === 'object') {
    source = source.headers && source.headers[this.correlation.HEADER_NAME];
  }
  if (!corrHeader.parse(source)) {
    return false;
  }
  return corrHeader;
};

var AppDynamics = function() {
  var self = this;

  var agent = new Agent();
  [ 'profile',
    'destroy',
    'getTransaction',
    'startTransaction',
    'parseCorrelationInfo'
  ].forEach(function(meth) {
    self[meth] = function() {
      return agent[meth].apply(agent, arguments);
    };
  });

  ['on',
   'addListener',
   'pause',
   'resume'
  ].forEach(function(meth) {
    self[meth] = function() {
      // deprecated
    };
  });

  // Here so jasmine tests can access
  // agent functions.
  self.__AppDynamics = AppDynamics;
  self.__agent = agent;
};

// Here so jasmine tests can access
// agent functions.
AppDynamics.Agent = Agent;

exports = module.exports = new AppDynamics();
