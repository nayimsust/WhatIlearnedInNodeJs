/*
Copyright (c) AppDynamics, Inc., and its affiliates
2015
All Rights Reserved
*/
'use strict';


// uncomment to generate proxy-funcs.js file

/*
var proxyFuncsContent = 'module.exports = {\n';
for(var i = 0; i < 250; i++) {
  proxyFuncsContent += '  ' + i + ': function(func) { return function appd_proxy_' + i + '() { return func.apply(this, arguments); }},\n';
}
proxyFuncsContent += '};\n';

var fs = require('fs');
require('fs').writeFile("proxy-funcs.js", proxyFuncsContent, function(err) {
  if(err) return console.error(err);

  console.log('done.');
});
return;
*/


var EventEmitter = require('events').EventEmitter;
var proxyFuncs = require('./proxy-funcs');


function Proxy(agent) {
  this.agent = agent;

  this.threadProxyMap = undefined;
  this.threadProxyIndex = undefined;

  this.callContextMap = undefined;
  this.callContextEnabled = undefined;
}
exports.Proxy = Proxy;


Proxy.prototype.init = function() {
  var self = this;

  // removeListener compairs objects, so the original callback
  // should be passed instead of the proxy
  self.before(EventEmitter.prototype, 'removeListener', function(obj, args) {
    if(args.length > 1 && args[1] && args[1].__appdynamicsProxy__) {
      args[1] = args[1].__appdynamicsProxy__;
    }
  });


  self.agent.on('btDetails', function(btDetails, transaction) {
    if(!self.callContextEnabled) return;

    var proxyId = self.threadProxyMap[transaction.threadId];
    if (proxyId >= 0) {

      if(btDetails.btInfoRequest &&
          btDetails.btInfoRequest.btIdentifier &&
          btDetails.btInfoRequest.btIdentifier.btID) {
        var callContext = {'btId' : btDetails.btInfoRequest.btIdentifier.btID};

        if(btDetails.snapshotInfo &&
            btDetails.snapshotInfo.snapshot.snapshotGUID) {
          callContext.snapshotGuid = btDetails.snapshotInfo.snapshot.snapshotGUID;
        }

        self.callContextMap['appd_proxy_' + proxyId] = callContext;
      }
    }
  });

  self.disableCallContext();
};

Proxy.prototype.enableCallContext = function() {
  var self = this;

  self.disableCallContext();
  self.callContextEnabled = true;
};

Proxy.prototype.disableCallContext = function() {
  var self = this;

  self.callContextEnabled = false;
  self.callContextMap = {};

  self.threadProxyMap = {};
  self.threadProxyIndex = -1;
};

Proxy.prototype.getCallContextMap = function() {
  var self = this;

  return self.callContextMap;
};

Proxy.prototype.generateThreadProxy = function(func, index) {
  var self = this;

  var proxyFuncGen = proxyFuncs[index];
  if(proxyFuncGen) {
    return proxyFuncGen(func);
  }

  return undefined;
};

Proxy.prototype.getThreadProxy = function(func) {
  var self = this;

  var threadId = self.agent.thread.current();

  if (threadId !== undefined) {
    // check if already mapped
    var threadProxyId = self.threadProxyMap[threadId];
    if (threadProxyId >= 0 ) {
      return self.generateThreadProxy(func, threadProxyId);
    }
    else {
      // try to get a free wrapper
      if (self.threadProxyIndex++ < 250) {
        // map wrapper id to thread id
        self.threadProxyMap[threadId] = self.threadProxyIndex;

        return self.generateThreadProxy(func, self.threadProxyIndex);
      }
    }
  }

  return undefined;
};

Proxy.prototype.wrapWithThreadProxyIfEnabled = function (realCallback) {
  if (!this.callContextEnabled) {
    return realCallback;
  }
  var result = this.getThreadProxy(realCallback);
  if (!result) {
    return realCallback;
  }
  return result;
};

var Locals = function() {
  this.time = undefined;
  this.stackTrace = undefined;
  this.params = undefined;
  this.opts = undefined;
  this.group = undefined;
  this.req = undefined;
  this.res = undefined;
  this.error = undefined;
  this.transaction = undefined;
  this.exitCall = undefined;
};

Proxy.prototype.before = function(obj, meths, hook, isCallbackHook) {
  var self = this;

  if(!obj) return false;

  if(!Array.isArray(meths)) meths = [meths];

  meths.forEach(function(meth) {
    var orig = obj[meth];
    if(!orig) return;

    obj[meth] = function appd_proxy() {
      if(isCallbackHook) {
        var selfProxy = this;

        // the hook code should contain try/catch
        hook(this, arguments, function() {
          return orig.apply(selfProxy, arguments);
        });
      }
      else {
        try {
          hook(this, arguments);
        }
        catch(e) {
          self.logError(e);
        }

        return orig.apply(this, arguments);
      }
    };
  });
};

Proxy.prototype.after = function(obj, meths, hook) {
  var self = this;

  if(!obj) return false;

  if(!Array.isArray(meths)) meths = [meths];

  meths.forEach(function(meth) {
    var orig = obj[meth];
    if(!orig) return;

    obj[meth] = function() {
      var ret = orig.apply(this, arguments);

      var hookRet;
      try {
        hookRet = hook(this, arguments, ret);
      }
      catch(e) {
        self.logError(e);
      }

      return hookRet || ret;
    };
  });
};

Proxy.prototype.around = function(obj, meths, hookBefore, hookAfter) {
  var self = this;

  if(!obj) return false;

  if(!Array.isArray(meths)) meths = [meths];

  meths.forEach(function(meth) {
    var orig = obj[meth];
    if(!orig) return;

    obj[meth] = function() {
      var locals = new Locals();

      try {
        hookBefore(this, arguments, locals);
      }
      catch(e) {
        self.logError(e);
      }

      var ret = orig.apply(this, arguments);

      var hookRet;
      try {
        hookRet = hookAfter(this, arguments, ret, locals);
      }
      catch(e) {
        self.logError(e);
      }

      return hookRet || ret;
    };
  });
};

Proxy.prototype.callback = function(args, pos, hookBefore, hookAfter) {
  var self = this;

  if(!args) return false;

  if(args.length <= pos) return false;
  if(pos === -1) pos = args.length - 1;

  var orig = (typeof args[pos] === 'function') ? args[pos] : undefined;
  if(!orig) return false;

  args[pos] = function appd_proxy() {
    if(hookBefore) {
      try {
        hookBefore(this, arguments);
      }
      catch(e) {
        self.logError(e);
      }
    }

    var ret = orig.apply(this, arguments);

    if(hookAfter) {
      try {
        hookAfter(this, arguments, ret);
      }
      catch(e) {
        self.logError(e);
      }
    }
    return ret;
  };

  if(self.callContextEnabled) {
    var threadProxy = self.getThreadProxy(args[pos]);
    if(threadProxy) {
      args[pos] = threadProxy;
    }
  }

  // this is needed for removeListener
  orig.__appdynamicsProxy__ = args[pos];
  return true;
};

Proxy.prototype.getter = function(obj, props, hook) {
  var self = this;

  if(!Array.isArray(props)) props = [props];

  props.forEach(function(prop) {
    var orig = obj.__lookupGetter__(prop);
    if(!orig) return;

    obj.__defineGetter__(prop, function() {
      var ret = orig.apply(this, arguments);

      try {
        hook(this, ret);
      }
      catch(e) {
        self.logError(e);
      }

      return ret;
    });
  });
};

Proxy.prototype.getErrorObject = function(args) {
  if(args && args.length > 0 && args[0]) {
    if(typeof(args[0]) === 'object' || typeof(args[0]) === 'string') {
      return args[0];
    }
    else {
      return 'unspecified';
    }
  }

  return undefined;
};

Proxy.prototype.logError = function(err) {
  this.agent.logger.error(err);
};
