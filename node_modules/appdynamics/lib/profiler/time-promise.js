/*
Copyright (c) AppDynamics, Inc., and its affiliates
2015
All Rights Reserved
*/
'use strict';


function TimePromise(agent, transactionInfo) {
  this.agent = agent;

  this.info = transactionInfo;
  this.stackTrace = undefined;
  this.time = undefined;

  // optional callbacks:
  this.beforeExitCall = null;
  this.exitCallCompleted = null;
  this.onSnapshotCaptured = null;
}

exports.TimePromise = TimePromise;

TimePromise.fromRequest = function(agent, req, txn) {
  var tp = new TimePromise(agent, req),
      profiler = agent.profiler;

  tp.time = txn.time;
  tp.stackTrace = profiler.stackTrace();
  tp.transaction = txn;
  txn.api = tp;

  return tp;
};

TimePromise.prototype.start = function() {
  var self = this;
  var profiler = self.agent.profiler;

  self.time = profiler.time(true);
  self.stackTrace = profiler.stackTrace();
  self.transaction = profiler.startTransaction(
    self.time, self.info, 'NODEJS_API');
  self.transaction.api = this;
};

TimePromise.prototype.resume = function(err) {
  if (!this.time) {
    throw new Error('transaction not started');
  }
  this.agent.thread.resume(this.time.threadId);
  this.transaction.touched = this.agent.system.millis();
};

TimePromise.prototype.markError = function(err, statusCode) {
  this.transaction.error = err;
  this.transaction.stackTrace = this.agent.profiler.formatStackTrace(err);
  this.transaction.statusCode = statusCode !== undefined ? statusCode :
                                err.statusCode !== undefined ? err.statusCode :
                                500;
};

TimePromise.prototype.end = function(err, statusCode) {
  var self = this;
  var profiler = self.agent.profiler;

  if(!self.time.done()) return;

  if (err) this.markError(err, statusCode);

  profiler.endTransaction(self.time, self.transaction, self.info);
};

TimePromise.prototype.startExitCall = function(exitCallInfo) {
  var profiler = this.agent.profiler;
  var callback = this.beforeExitCall;
  var time = profiler.time();

  try {
    this.beforeExitCall = null; // bypass callback for explicit create
    return profiler.createExitCall(time, exitCallInfo);
  } finally {
    this.beforeExitCall = callback; // restore any callback
  }
};

TimePromise.prototype.endExitCall = function(exitCall, error) {
  var time = exitCall.time;
  if (!time.done()) return;
  this.agent.profiler.addExitCall(exitCall.time, exitCall, error);
};

TimePromise.prototype.createCorrelationInfo = function(exitCall, doNotResolve) {
  var header = this.agent.correlation.newCorrelationHeader();
  header.build(this.transaction, exitCall, !!doNotResolve);
  return header.getStringHeader();
};

TimePromise.prototype.addSnapshotData = function(key, value) {
  this.snapshotData = this.snapshotData || [];
  this.snapshotData.push({ name: key, value: value });
};

TimePromise.prototype.addAnalyticsData = function(key, value) {
  this.analyticsData = this.analyticsData || [];
  this.analyticsData.push({ name: key, value: value });
};
